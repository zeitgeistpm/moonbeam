window.SIDEBAR_ITEMS = {"struct":[["AddressU64",""],["AllowDelegateCall","DELEGATECALL is allowed. Should be used with care if the precompile use custom storage, as the caller could impersonate its own caller."],["ForbidDelegateCall","DELEGATECALL is forbiden."],["LimitRecursionTo","A precompile can (even indirectly) call itself with N levels of nesting. 0 = anyone can call the precompile but a subcall of the precompile will not be able to call it back (re-entrancy protection)."],["PrecompileAt","Wraps a stateless precompile: a type implementing the `Precompile` trait. Type parameters allow to define:"],["PrecompileSetBuilder","Wraps a tuple of `PrecompileSetFragment` to make a real `PrecompileSet`."],["PrecompileSetStartingWith","Wraps an inner PrecompileSet with all its addresses starting with a common prefix. Type parameters allow to define:"],["PrecompilesInRangeInclusive","Wraps a precompileset fragment into a range, and will skip processing it if the address is out of the range."],["RevertPrecompile","Make a precompile that always revert. Can be useful when writing tests."],["StatefulPrecompileAt","Wraps a stateful precompile: a type implementing the `StatefulPrecompile` trait. Type parameters allow to define:"],["UnlimitedRecursion","There is no limit to the amount times a precompiles can call itself recursively. Should be used with care as it could cause stack overflows."]],"trait":[["DelegateCallSupport","Is DELEGATECALL allowed to use for a precompile."],["PrecompileSetFragment","A fragment of a PrecompileSet. Should be implemented as is it was a PrecompileSet containing only the precompile(set) it wraps. They can be combined into a real PrecompileSet using `PrecompileSetBuilder`."],["RecursionLimit","How much recursion is allows for a precompile."]],"type":[["ForbidRecursion",""]]};